Основной алгоритм записывается достаточно просто после того, как учтено, каким образом хранятся данные, и реализована схема для равномерных сеток.
Основные детали алгоритма могут быть записаны в следующем виде:
\begin{minted}{julia}
function solve(problem::HeatProblem, grid_params)
    # учёт начальных условий
    initial_conditions!(problem, grid_params)

    # Идём по всем временным слоям
    for j in 1:(grid_params.Nt - 1)
        levels[j + 1] = deepcopy(levels[j])
        advance_level!(problem, levels[j + 1])
    end
end
\end{minted}
Функция \texttt{initial\_conditions!} устанавливает значение в момент времени $t_1$, то есть для каждой точки $(x, y)$ блочной сетки, для каждого уровня считается значение $u_0(x, y)$.

Затем выполняется послойное обновление решения: зная $u(x, y, t_j)$ для любых $(x, y) \in \omega$ (то есть зная решение на временном слое $t_j$), находится решение на следующем временном слое $t_{j + 1}$ с помощью функции \texttt{advance\_level!}.
Эта функция вызывается на коневом уровне $l = 1$, а затем рекурсивно на всех подуровнях.
Это иллюстрирует листинг:
\begin{minted}{julia}
function advance_level!(problem::HeatProblem, level::Level)
    for i in 1:r_l # r_l --- refinement ratio
        numerical_update_u(problem, level)
        if has_sublevel(level)
            advance_level!(problem, level.sublevel)
        end
        level.t_curr += level.delta_t
    end
    interpolate_fine_to_coarse(level)
end
\end{minted}
С помощью локально-одномерной схемы функция \texttt{numerical\_update\_u} обновляет решение на уровне \texttt{level}, и если уровень имеет подуровень (\texttt{has\_sublevel(level) == true}), выполняется обновление на этом подуровне.
Причём, обновление на подуровне происходит $r_l$ раз, то есть соответствует \eqref{eq:frac_time_step}.
В нашем случае $r_l = 2 \quad \forall l > 1$, что значит, что переход $t_j \mapsto t_{j + 1}$ от старого временного слоя к новому на уровне $l$ будет осуществляться за $2^{l - 1}$ шагов.

Отметим ещё одну особенно важную часть алгоритма, требующую отдельного подробного исследования, и поэтому не рассмотренную в работе: перестройку сетки с учётом особенностей решения.
После того, как получено решение на новом временном слое, необходимо проанализировать полученное решение и найти новое положение особенностей решения.
Запускается так называемый процесс индикации перестройки (refinement indication).
Индикатор оценивает текущую точность численного решения и отмечает области сетки, в которых нужна большая/меньшая точность.
Было предложено достаточно большое количество индикаторов (например, в работах \cite{berger1989local, berger1982adaptive, lohner1987adaptive}).
После того, как были отмечены точки, в которых требуется большая точность, запускается процесс перестройки сетки (regridding).
Задача состоит в том, чтобы покрыть отмеченные точки блоками мелкой сетки таким образом, чтобы неотмеченных точек, попадающих в мелкую сетку было как можно меньше (то есть покрытие особенностей решения оптимальным образом, так называемый clustering algorithm).
Также, как и с индикаторами, существует множество различных алгоритмов кластеризации, с некоторыми вариантами можно ознакомиться в \cite{berger1989local, deiterding2011block}.