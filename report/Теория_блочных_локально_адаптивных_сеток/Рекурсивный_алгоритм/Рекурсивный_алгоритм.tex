Основной алгоритм записывается достаточно просто после того, как учтено, каким образом хранятся данные, и реализована схема для равномерных сеток.
Основные детали алгоритма могут быть записаны в следующем виде:
\begin{minted}{julia}
function solve(problem::HeatProblem, grid_params)
    # учёт начальных условий
    initial_conditions!(problem, grid_params)

    # Идём по всем временным слоям
    for j in 1:(grid_params.Nt - 1)
        levels[j + 1] = deepcopy(levels[j])
        advance_level!(problem, levels[j + 1])
    end
end
\end{minted}
То есть для каждого временного шага выполняется вычисление решения на корневом уровне \texttt{levels[j + 1]}, которое, в свою очередь, записывается в виде рекурсивного алгоритма:
\begin{minted}{julia}
function advance_level!(problem::HeatProblem, level::Level)
    for i in 1:r_l # r_l --- refinement ratio
        numerical_update_u(problem, level)
        if has_sublevel(level)
            advance_level!(problem, level.sublevel)
        end
        level.t_curr += level.delta_t
    end
    interpolate_fine_to_coarse(level)
end
\end{minted}
Численное обновление \texttt{numerical\_update} происходит на всех блоках в уровне \texttt{level} с помощью локально-одномерной схемы.

Отметим ещё одну особенно важную часть алгоритма, требующую отдельного подробного исследования, и поэтому не рассмотренную в работе: перестройку сетки с учётом особенностей решения.
После того, как получено решение на новом временном слое, необходимо проанализировать полученное решение и найти новое положение особенностей решения.
Запускается так называемый процесс индикации перестройки (refinement indication).
Индикатор оценивает текущую точность численного решения и отмечает области сетки, в которых нужна большая/меньшая точность.
Было предложено достаточно большое количество индикаторов (например, в работах \cite{berger1989local, berger1982adaptive, lohner1987adaptive}).
После того, как были отмечены точки, в которых требуется большая точность, запускается процесс перестройки сетки (regridding).
Задача состоит в том, чтобы покрыть отмеченные точки блоками мелкой сетки таким образом, чтобы неотмеченных точек, попадающих в мелкую сетку было как можно меньше (то есть покрытие особенностей решения оптимальным образом, так называемый clustering algorithm).
Также, как и с индикаторами, существует множество различных алгоритмов кластеризации, с некоторыми вариантами можно ознакомиться в \cite{berger1989local, deiterding2011block}.