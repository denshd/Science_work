Очевидно использовать обыкновенные многомерные массивы для хранения данных численного решения на таких блочных сетках невозможно, а точнее, неэффективно.
Задача отыскания наиболее удобного и оптимального формата хранения данных на сетках с локальной адаптацией~--- одна из ключевых.
Существует несколько методов.
Так, в \cite{АфендиковЛАД} используются древовидные структуры (четвертичные и восьмиричные деревья).
В этой работе для хранения данных используется двусвязный список.
Каждый уровень \texttt{Level} описывается следующей структурой (несущественные в идеологическом плане тонкости реализации опускаются в коде):
\begin{minted}{julia}
struct Level
    level_number::Int # номер уровня в иерархии уровней
    sublevel::Union{Nothing, Level} # подуровень
    suplevel::Union{Nothing, Level} # надуровень

    blocks::Vector{Block} # массив блоков сеток
    M::Int # число блоков сетки

    t_curr::Real # Текущее время на уровне
    delta_t::Real # Временной шаг уровня
end
\end{minted}
Поля \texttt{sublevel} и \texttt{suplevel} имеют тип \texttt{Union\{Nothing, Level\}}, что означает, что эти переменные могут быть как типа \texttt{Level} (то есть быть ссылкой на под- или над- уровни соответственно), так и типа \texttt{Nothing} (то есть не существовать, а значит, уровень не имеет подуровня (последний уровень измельчения) или надуровня (уровень является корневым)).
Тип блок имеет вид:
\begin{minted}{julia}
struct Block
    spacial_grid::UniformGrid # Сетка

    # Координаты `((x1, x2), (y1, y2))` положения блока в
    # надблоке (в индексных координатах надблока)
    supblock_position::Tuple{Tuple{Int, Int}, Tuple{Int, Int}}
    
    u::Matrix{Real} # Решение
end
\end{minted}
\texttt{UniformGrid}~--- удобное представление равномерной сетки, которая использовалась ранее.